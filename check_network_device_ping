#!/usr/bin/perl -w

#########################################################################

#
# Copyright (c) 2016 Marko Dinic <marko@yu.net>. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#########################################################################

our (%PARAMS, %CONFIG, %PARAMS_DEFAULTS, %CONFIG_DEFAULTS);
our ($PROGRAM, $VERSION);
our $USAGE;

#########################################################################

($PROGRAM) = ($0 =~ /([^\/]+)$/);

$VERSION = "0.2";

#########################################################################
##      O P T I O N A L   S T A T I C   C O N F I G U R A T I O N      ##
#########################################################################

%PARAMS = ();
%CONFIG = ();

#########################################################################
##                          D E F A U L T S                            ##
#########################################################################

%PARAMS_DEFAULTS = (
    'size'		=> 100,
    'packets'		=> 5,
    'timeout'		=> 2
);

%CONFIG_DEFAULTS = (
    'maxattempts'	=> 3,
    'maxidle'		=> 60,
    'sockdir'		=> "/var/tmp"
);

#########################################################################
##                         I N T E R N A L S                           ##
#########################################################################


#########################################################################

use constant {
    RC_OK		=> 0,
    RC_WARNING		=> 1,
    RC_CRITICAL		=> 2,
    RC_UNKNOWN		=> 3
};

use constant {
    CLI_PROMPT		=> '.*?[>#]\s*$',
    PAGE_MARKER		=> '\-+\s*More\s*\-+'
};

#########################################################################

use strict;
use warnings;

#########################################################################

use Net::Telnet;

use Getopt::Std;

use Digest::MD5 qw(md5_base64);
use IO::Select;
use IO::Socket::UNIX;
use Storable qw(nstore_fd fd_retrieve);

use Data::Dumper;

#########################################################################
##                   H E L P E R   F U N C T I O N S                   ##
#########################################################################

sub HELP_MESSAGE
{
    print STDERR <<EOF
$PROGRAM [options]

 -H <target_address>          Target (pinged) device's address

 -w <wrta>,<wpl>%             Warning threshold for average RTT and packet loss
 -c <crta>,<cpl>%             Critical threshold for average RTT and packet loss

 -D <remote_address>          Network device that will do the pinging
 -T <type>                    Type of pinging device (os/vendor):

                               ios
                               iosxr
                               force10
                               powerconnect
                               junos

                              Default: autodetect

 -U <username>                Pinging device's username
 -P <password>                Pinging device's password
 -E <secret>                  Elevated privilege level secret (ie. Cisco enable)

 -p <packets>                 Number of pings to send
 -s <size>                    Ping packets' size
 -t <timeout>                 Ping reply timeout

 -S <source>                  Ping packets' source address or interface
 -V <VRF>                     VRF to use instead of global routing table

 -4|6                         Use IPv4 or IPv6 explicitly

 -d                           Enable debugging

EOF
}

sub error(;$)
{
    my $message = shift;

    # If exit message was specified - print it
    if(defined($message) && $message ne '') {
	print STDERR "ERROR: ".$message."\n\n";
    }

    # Display help
    HELP_MESSAGE();

    return RC_UNKNOWN;
}

sub is_ipv4($)
{
    return (defined($_[0]) && $_[0] =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:\/\d{1,2})?$/) ? 1:0;
}

sub is_ipv6($)
{
    return (defined($_[0]) && $_[0] =~ /^[a-fA-F\d]{0,4}(?:\:(?!\:\:)[a-fA-F\d]{1,4}){0,6}(?:\:\:)?(?:[a-fA-F\d]{1,4}\:(?!\:\:)){0,6}[a-fA-F\d]{0,4}(?:\/\d{1,2})?$/) ? 1:0;
}

sub nslookup($)
{
    my $host = shift;
    my $addr;

    # getaddrinfo() and getnameinfo() are a mess - they are
    # missing from Socket module on some linux distributions
    # (or are otherwise unavailable), but not all. They can
    # also be found in Socket6 and Socket::GetAddrInfo modules,
    # but these are not installed by default. We will look for
    # them in all those places and if they are not found, we
    # will fall back to shell command 'host' (if installed).

    eval {
	eval {
	    eval {
		# Try Socket module
		eval {
		    require Socket;
		    import Socket qw(getaddrinfo getnameinfo NI_NUMERICHOST NIx_NOSERV);
		};
		# If not present in Socket,
		# look for Socket6 module
		if($@) {
		    require Socket6;
		    import Socket6;
		}
	    };
	    # If Socket6 module is missing,
	    # look for Socket::GetAddrInfo
	    if($@) {
		require Socket::GetAddrInfo;
		import Socket::GetAddrInfo qw(:newapi getaddrinfo getnameinfo NI_NUMERICHOST);
	    }
	    # If we reached this part,
	    # we found something
	    my ($err, $ai) = getaddrinfo($host, 0);
	    ($err, $addr) = getnameinfo($ai->{'addr'}, &NI_NUMERICHOST);
	};
	# If all else fails, try good ol' 'host' command
	if($@) {
	    ($addr) = (`host $host` =~ /has\s+(?:IPv6\s+)?address\s+([^\s\n\r]+)$/i);
	    die unless defined($addr) && $addr ne '';
	}
    };

    return ($@) ? $host:$addr;
}

#########################################################################
##             F R O N T E N D < - > D A E M O N   I P C               ##
#########################################################################

sub ipc_read($)
{
    my $socket = shift;

    return fd_retrieve($socket);
}

sub ipc_write($$)
{
    my ($socket, $data) = @_;

    return nstore_fd($data, $socket);
}

sub ipc_digest($$)
{
    my ($user, $pass) = @_;

    $user = '' unless defined($user);
    $pass = '' unless defined($pass);

    return md5_base64("\0".length($user)."\0".length($pass)."\0".$user.":".$pass);
}

#########################################################################
##                     D A E M O N   O U T P U T                       ##
#########################################################################

sub print_stdout($$)
{
    my ($socket, $message) = @_;

    ipc_write($socket, { 'stdout' => $message });
}

sub print_stderr($$)
{
    my ($socket, $message) = @_;

    ipc_write($socket, { 'stderr' => $message });
}

sub return_code($$)
{
    my ($socket, $code) = @_;

    ipc_write($socket, { 'code' => $code });
}

sub return_stats($$)
{
    my ($socket, $stats) = @_;

    ipc_write($socket, { 'stats' => $stats, 'code' => RC_OK });
}

#########################################################################
##               N E T W O R K   D E V I C E   C O R E                 ##
#########################################################################

sub detect_device_type($)
{
    my $conn = shift;

    # Request system version. Most platforms support this command
    $conn->put("show version\n");
    # Collect output up to command prompt or pagination marker
    my ($version, $prompt) = $conn->waitfor('/(?:'.PAGE_MARKER.'|'.CLI_PROMPT.')/i');
    # If output is paginated ...
    if(defined($prompt) && $prompt =~ /@{[PAGE_MARKER]}/i) {
	# ... end pagination
	$conn->put("q");
	$conn->waitfor('/'.CLI_PROMPT.'/');
    }

    # If version info is available, attempt platform detection
    if(defined($version) && $version ne '') {
	return 'ios' if $version =~ /Cisco IOS Software/i;
	return 'iosxr' if $version =~ /Cisco IOS XR Software/i;
	return 'force10' if $version =~ /Force10/i;
	return 'powerconnect' if $version =~ /PowerConnect/i;
	return 'junos' if $version =~ /JUNOS/i;
    }

    return '';
}

sub device_connect($$$$;$)
{
    my ($frontend, $device, $user, $pass, $debug) = @_;

    # Create new telnet session
    my $conn = Net::Telnet->new(Prompt => '/'.CLI_PROMPT.'/',
				Errmode => 'return',
				Timeout => 10);

    return undef unless defined($conn);

    # Telnet to remote network device
    $conn->open($device)
	or return undef;

    print_stdout($frontend, "Connected to remote network device ".$device."\n") if $debug;

    # Send username, if defined
    if(defined($user) && $user ne '') {
	print_stdout($frontend, "Sending username\n") if $debug;
	unless($conn->waitfor('/(?:[Uu]ser(?:name)?|[Ll]ogin):/')) {
	    print_stderr($frontend, "Username failed\n") if $debug;
	    $conn->close();
	    return undef;
	}
	$conn->put($user."\n");
    }

    # Send password, if defined
    if(defined($pass) && $pass ne '') {
	print_stdout($frontend, "Sending password\n") if $debug;
	unless($conn->waitfor('/[Pp]ass(?:word)?:/')) {
	    print_stderr($frontend, "Password failed\n") if $debug;
	    $conn->close();
	    return undef;
	}
	$conn->cmd($pass)
	    or return undef;
    }

    print_stdout($frontend, "Authenticated to remote network device ".$device."\n") if $debug;

    return $conn;
}

sub device_daemon($$;$$$$$)
{
    # Fork into background
    my $pid = fork();
    return 0 unless defined($pid);
    return 1 if $pid > 0;

    # Daemon process starts here
    my ($sockpath, $device, $type, $user, $pass, $debug, $maxidle) = @_;
    my ($conn, $detected, $ping);

    # Initial daemon process's title
    my $proctitle = $PROGRAM." daemon";
    $0 = $proctitle;

    # Remove stale socket if present
    if(-S $sockpath) {
	unlink($sockpath);
    }

    # UNIX socket to talk to our frontend
    my $listener = IO::Socket::UNIX->new(Type => &SOCK_STREAM,
					 Local => $sockpath,
					 Listen => 1,
					 Blocking => 0);

    exit(RC_UNKNOWN) unless defined($listener);

    # Monitor listener socket
    my $select = IO::Select->new();
    $select->add($listener);

    my $idle_timeout = time() + $maxidle;

l:  while(time() < $idle_timeout) {

	$0 = $proctitle.", idle shutdown in ".($idle_timeout - time())." sec";

	# Wait until listening socket is ready
	my @ready = $select->can_read(0.1);
	next unless @ready;

	foreach my $socket (@ready) {

	    # If ready socket is the listening socket ...
	    if($socket == $listener) {
		# ... we have incoming connection
		my $frontend = $socket->accept();
		# Make frontend connection non-blocking
		$frontend->blocking(0);
		# Add frontend connection to the monitor
		$select->add($frontend);
		next;
	    }

	    # Get ping parameters from our frontend
	    my $params = ipc_read($socket);

	    # If socket was ready, but we got no params,
	    # frontend disconnected from the socket
	    unless(defined($params)) {
		return_code($socket, RC_UNKNOWN);
		$select->remove($socket);
		$socket->close();
		next;
	    }

	    # If params contain debug flag (and they should) ...
	    if(defined($params->{'debug'})) {
		# ... replace daemon's current debug setting
		$debug = $params->{'debug'};
	    }

	    # Parameters must be 'signed' with MD5 digest
	    # formatted from device's login credentials.
	    # This ensures the frontend is invoked with
	    # proper device credentials while daemon is
	    # running. Otherwise, device credentials
	    # would be required only to allow daemon to
	    # initially authenticate to the remote device,
	    # but since the session is established from
	    # that point on, subsequent frontend runs
	    # would simply land in the middle of already
	    # established CLI session without auth.
	    unless($params->{'digest'} eq ipc_digest($user, $pass)) {
		print_stderr($socket, "Invalid credentials for device ".$device."\n") if $debug;
		return_code($socket, RC_UNKNOWN);
		$select->remove($socket);
		$socket->close();
		next;
	    }

	    # If not connected to the device yet ...
	    unless(defined($conn)) {
		# ... attempt to connect now
		$conn = device_connect($socket, $device, $user, $pass, $debug);
		unless(defined($conn)) {
		    print_stderr($socket, "Failed to connect to network device ".$device."\n") if $debug;
		    return_code($socket, RC_UNKNOWN);
		    $select->remove($socket);
		    $socket->close();
		    last l;
		}
		# If device type wasn't specified ...
		unless(defined($type) && $type ne '') {
		    # ... attempt to detect it
		    $detected = detect_device_type($conn);
		    # If device type was detected ...
		    if(defined($detected) && $detected ne '') {
			print_stdout($socket, "Detected network device type ".$detected."\n") if $debug;
			# ... force device-specific ping function lookup
			undef $ping;
		    }
		}
		# Set telnet cmd (send command, wait for prompt) timeout
		$conn->timeout($params->{'timeout'} * ($params->{'packets'} + 1));
		# Set daemon proctitle to reflect connected state
		$proctitle .= " connected to ".$device;
		$0 = $proctitle;
	    }

	    # If device-specific ping function isn't known ...
	    unless(defined($ping) && ref($ping) eq 'CODE') {
		my $device_type = (defined($type) && $type ne '') ? $type:$detected;
		# Determine device-specific ping function
		$ping = __PACKAGE__->can('__'.$device_type.'_ping');
		# If device type is supported, platform-specific
		# ping function exists and we have coderef to it
		unless(defined($ping) && ref($ping) eq 'CODE') {
		    # Otherwise, this device type is not supported
		    print_stderr($socket, "Unsupported device type ".$type."\n") if $debug;
		    return_code($socket, RC_UNKNOWN);
		    $select->remove($socket);
		    $socket->close();
		    last l;
		}
	    }

	    # Reset idle timeout
	    $idle_timeout = time() + $maxidle;

	    # Ping the target
	    my $stats = $ping->($socket, $conn, %{$params});

	    # If we received ping statistics ...
	    if(defined($stats)) {
		# ... send them to the frontend
		return_stats($socket, $stats);
	    # Otherwise ...
	    } else{
		# ... return generic error code
		return_code($socket, RC_UNKNOWN);
	    }

	    # Disconnect the frontend
	    $select->remove($socket);
	    $socket->close();
	}

    }

    # If connected to the remote device ...
    if(defined($conn)) {
	# ... end CLI session
	$conn->put("exit");
	# ... close telnet session
	$conn->close();
    }

    # If listening on UNIX socket ...
    if(defined($listener)) {
	# ... stop monitoring socket
	$select->remove($listener);
	# ... close it
	$listener->close();
    }

    # If socket file exists ...
    if(-S $sockpath) {
	# ... remove it
	unlink($sockpath);
    }

    # Done
    exit(0);
}

#########################################################################
##                              M A I N                                ##
#########################################################################

sub main()
{
    my %cf = (%CONFIG_DEFAULTS, %CONFIG);

    return error "Script config is invalid/incomplete" unless(defined($cf{'maxattempts'}) &&
								      $cf{'maxattempts'} =~ /^\d+$/ &&
								      $cf{'maxattempts'} >= 0 &&
							      defined($cf{'maxidle'}) &&
								      $cf{'maxidle'} =~ /^\d+$/ &&
								      $cf{'maxidle'} >= 0 &&
							      defined($cf{'sockdir'}) &&
								      -d $cf{'sockdir'});

    my %opts = ();

    # Parse command line arguments
    $Getopt::Std::STANDARD_HELP_VERSION = 1;
    getopts("D:T:U:P:E:H:S:V:p:s:t:w:c:d46", \%opts);

    my %params = (%PARAMS_DEFAULTS, %PARAMS);
    my ($device, $type);
    my ($user, $pass);
    my ($warn_rta, $warn_pl);
    my ($crit_rta, $crit_pl);
    my $debug;

    # Statically configured ping parameters
    # can be overrriden by runtime options
    while(my ($opt, $val) = each %opts) {
	# Process available options
	if($opt eq 'D') {
	    return error "Missing/invalid pinging device hostname/address" unless $val ne '';
	    # Set pinging device address
	    $device = $val;
	} elsif($opt eq 'T') {
	    return error "Missing/invalid pinging device type (os/vendor)" unless defined($val);
	    # Set pinging device type
	    $type = $val if $val ne '';
	} elsif($opt eq 'U') {
	    return error "Missing pinging device username" unless defined($val);
	    # Set pinging device's telnet username
	    $user = $val if $val ne '';
	} elsif($opt eq 'P') {
	    return error "Missing pinging device password" unless defined($val);
	    # Set pinging device's telnet password
	    $pass = $val if $val ne '';
	} elsif($opt eq 'E') {
	    return error "Missing pinging device enable password" unless defined($val);
	    # Set pinging device's enable password
	    $params{'enable'} = $val if $val ne '';
	} elsif($opt eq 'H') {
	    return error "Missing ping target hostname/address" unless $val ne '';
	    # Set ping target address
	    $params{'target'} = (is_ipv4($val) || is_ipv6($val)) ? $val:nslookup($val);
	} elsif($opt eq 'S') {
	    return error "Missing ping source address/interface" unless defined($val);
	    # Set ping source address
	    $params{'source'} = $val if $val ne '';
	} elsif($opt eq 'V') {
	    return error "Missing/invalid VRF" unless defined($val);
	    # Set pinging source VRF
	    $params{'vrf'} = $val if $val ne '';
	} elsif($opt eq 'p') {
	    return error "Missing packet count" unless defined($val);
	     # Set the number of packets to ping with
	    $params{'packets'} = $val if($val =~ /^\d+$/ && $val > 0);
	} elsif($opt eq 's') {
	    return error "Missing packet size" unless defined($val);
	    # Set the ping packet size
	    $params{'size'} = $val if($val =~ /^\d+$/ && $val > 35);
	} elsif($opt eq 't') {
	    return error "Missing ping timeout" unless defined($val);
	    # Set the ping timeout
	    $params{'timeout'} = $val if($val =~ /^\d+$/ && $val > 0);
	} elsif($opt eq 'w') {
	    return error "Missing warning thresholds" unless $val ne '';
	    # Extract average RTT and packed loss thresholds
	    ($warn_rta, $warn_pl) = ($val =~ /^(\d+),(\d+)\%$/);
	    unless(defined($warn_rta) && $warn_rta ne '' &&
		   defined($warn_pl) && $warn_pl ne '') {
		return error "Invalid warning thresholds ".$val;
	    }
	} elsif($opt eq 'c') {
	    return error "Missing critical thresholds" unless $val ne '';
	    # Extract average RTT and packed loss thresholds
	    ($crit_rta, $crit_pl) = ($val =~ /^(\d+),(\d+)\%$/);
	    unless(defined($crit_rta) && $crit_rta ne '' &&
		   defined($crit_pl) && $crit_pl ne '') {
		return error "Invalid critical thresholds ".$val;
	    }
	} elsif($opt eq '4') {
	    $params{'af'} = 4;
	} elsif($opt eq '6') {
	    $params{'af'} = 6;
	} elsif($opt eq 'd') {
	    # Enable debugging
	    $params{'debug'} = $debug = 1;
	} else {
	    return error;
	}
    }

    # Check for mandatory parameters: device, target and thresholds
    # and do internal configuration sanity chech
    return error unless(defined($params{'target'}) &&
				$params{'target'} ne '' &&
			defined($device) &&
				$device ne '' &&
			defined($warn_rta) &&
				$warn_rta =~ /^\d+$/ &&
				$warn_rta >= 0 &&
			defined($warn_pl) &&
				$warn_pl  =~ /^\d+$/ &&
				$warn_pl >= 0 &&
			defined($crit_rta) &&
				$crit_rta =~ /^\d+$/ &&
				$crit_rta >= 0 &&
			defined($crit_pl) &&
				$crit_pl =~ /^\d+$/ &&
				$crit_pl >= 0);


    # Resolve network device name into an IPv4/IPv6 address
    my $devaddr = (is_ipv4($device) || is_ipv6($device)) ? $device:nslookup($device);
    return RC_UNKNOWN unless(defined($devaddr) && $devaddr ne '');

    # UNIX socket name will be the IP address of the device
    my $sockpath = $cf{'sockdir'}."/".$devaddr.".sock";

    my ($daemon, $pid);

    # Try to connect to the device daemon
    for(1..$cf{'maxattempts'}) {
	# Connect to device daemon via UNIX socket
	$daemon = IO::Socket::UNIX->new(Type => &SOCK_STREAM,
					Peer => $sockpath,
					Blocking => 0);
	# Connection was successful, we are done
	if(defined($daemon)) {
	    print "Attached to device ".$device." daemon\n" if $debug;
	    last;
	}
	# If connection failed, assume
	# that daemon isn't running
	unless($pid) {
	    # Start the daemon
	    $pid = device_daemon($sockpath,
				 $device,
				 $type,
				 $user,
				 $pass,
				 $debug,
				 $cf{'maxidle'});
	    # Daemon launch failed ?
	    return RC_UNKNOWN unless defined($pid);
	    print "Started device ".$device." daemon\n" if $debug;
	}
	# Wait before retrying
	sleep(1);
    }

    return RC_UNKNOWN unless defined($daemon);

    # Monitor connection to the daemon for incoming data
    my $select = IO::Select->new();
    $select->add($daemon);

    my ($stats, $code);

    # Add auth digest to parameters
    $params{'digest'} = ipc_digest($user, $pass);

    # Send serialized ping parameters to the daemon
    ipc_write($daemon, \%params);

    print "Sent ping parameters to the daemon\n" if $debug;

    # Read daemon output
    while(1) {
	# Wait until daemon sends some data,
	# or connection closes
	next unless $select->can_read(0.1);
	# Get input from daemon
	my $message = ipc_read($daemon);
	# If socket was ready, but we got no data,
	# we got disconnected from the socket
	last unless $message;
	# If daemon sent data to be written to stdout ...
	if(defined($message->{'stdout'})) {
	    # ... write it to stdout
	    print STDOUT $message->{'stdout'};
	}
	# If daemon sent data to be written to stderr ...
	if(defined($message->{'stderr'})) {
	    # ... write it to stderr
	    print STDERR $message->{'stderr'};
	}
	# If daemon sent ping stats ...
	if(defined($message->{'stats'})) {
	    # ... keep them
	    $stats = $message->{'stats'};
	}
	# If daemon sent exit code ...
	if(defined($message->{'code'})) {
	    # ... keep the code ...
	    $code = $message->{'code'};
	    # ... and end the loop
	    last;
	}
    }

    # Disconnect from the daemon
    $daemon->close();

    # If daemon returned a non-0 exit code,
    # we will exit with that code
    return $code if $code;

    # If we got no stats, we cannot do anything
    return RC_UNKNOWN unless defined($stats);

    print Dumper($stats)."\n" if $debug;

    # We must have at least the number of sent/received packets
    return RC_UNKNOWN unless(defined($stats->{'received'}) &&
				     $stats->{'received'} =~ /^\d+(?:\.\d+)?$/ &&
			     defined($stats->{'sent'}) &&
				     $stats->{'sent'} =~ /^\d+(?:\.\d+)?$/);

    # Calculate packet loss percentage
    my $packet_loss = sprintf("%.2f", (100 * (1 - ($stats->{'received'} / $stats->{'sent'}))));

    # Format average RTT
    my $rtt_average = (defined($stats->{'rttavg'}) &&
		       $stats->{'rttavg'} =~ /^\d+(?:\.\d+)?$/) ?
					sprintf("%.2f", $stats->{'rttavg'}):undef;

    my $rc = RC_OK;

    # Check if packet loss exceeds user-specified critical level
    if($packet_loss >= $crit_pl) {
	$rc = RC_CRITICAL;
    # Check if RTT average exceeds user-specified critical level
    } elsif(defined($rtt_average) && $rtt_average >= $crit_rta) {
	$rc = RC_CRITICAL;
    # Check if packet loss exceeds user-specified warning level
    } elsif($packet_loss >= $warn_pl) {
	$rc = RC_WARNING;
    # Check if RTT average exceeds user-specified warning level
    } elsif(defined($rtt_average) && $rtt_average >= $warn_rta) {
	$rc = RC_WARNING;
    }

    my %rc_str = (
	&RC_OK		=> "OK",
	&RC_WARNING	=> "WARNING",
	&RC_CRITICAL	=> "CRITICAL"
    );

    print "PING ".$rc_str{$rc}." - Packet loss = ".$packet_loss."%";
    print ", RTA = ".$rtt_average." ms" if defined($rtt_average);
    print "\n";

    return $rc;
}

#########################################################################
##                  C I S C O   I O S   D E V I C E                    ##
#########################################################################

sub __ios_ping($$;%)
{
    my $frontend = shift;
    my $conn = shift;

    # Get ping parameters
    my ($enable, $target, $af, $source, $packets, $size, $timeout, $vrf, $debug) =
	@{{@_}}{('enable', 'target', 'af', 'source', 'packets', 'size', 'timeout', 'vrf', 'debug')};

    return undef unless(defined($target) && $target ne '');

    # Change to enable mode, if defined
    if(defined($enable) && $enable ne '') {
	print_stdout($frontend, "Sending enable password\n") if $debug;
	unless($conn->cmd(String => "enable\n".$enable, Timeout => 10)) {
	    print_stderr($frontend, "Enable failed\n") if $debug;
	    return undef;
	}
    }

    # Format ping command
    my $cmd = "ping";
    # Add VRF parameter if defined
    if(defined($vrf) && $vrf ne '') {
	$cmd .= " vrf ".$vrf;
    }
    # Add address family if defined
    if(defined($af) && $af ne '') {
	my $family = {4 => 'ip', 6 => 'ipv6'}->{$af};
	if(defined($family) && $family ne '') {
	    $cmd .= " ".$family;
	}
    }
    # Add ping target
    $cmd .= " ".$target;
    # Ping with packet parameters requires enable mode
    if(defined($enable) && $enable ne '') {
	# Optional ping source address/interface
	if(defined($source) && $source ne '') {
	    $cmd .= " source ".$source;
	}
	# Optional packet count parameter
	if(defined($packets) && $packets ne '') {
	    $cmd .= " repeat ".$packets;
	}
	# Optional size parameter
	if(defined($size) && $size ne '') {
	    $cmd .= " size ".$size;
	}
	# Optional ping timeout parameter
	if(defined($timeout) && $timeout ne '') {
	    $cmd .= " timeout ".$timeout;
	}
    }

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd."\n") if $debug;

    # Issue ping command and get the command's output
    my @output = $conn->cmd($cmd);

    # The last line of output contains the ping summary
    my $summary = pop @output;
    return undef unless defined($summary);

    chomp $summary;
    return undef unless $summary ne '';

    print_stdout($frontend, $summary."\n") if $debug;

    my %result;

    # Extract summary information
    @result{('received', 'sent', 'rttmin', 'rttavg', 'rttmax')} = ($summary =~ /^Success rate is \d+ percent \((\d+)\/(\d+)\)(?:, round\-trip min\/avg\/max = (\d+)\/(\d+)\/(\d+) ms)?$/i);

    return \%result;
}

#########################################################################
##              C I S C O   I O S   X R   D E V I C E                  ##
#########################################################################

sub __iosxr_ping($$;%)
{
    my $frontend = shift;
    my $conn = shift;

    # Get ping parameters
    my ($target, $af, $source, $packets, $size, $timeout, $vrf, $debug) =
	@{{@_}}{('target', 'af', 'source', 'packets', 'size', 'timeout', 'vrf', 'debug')};

    return undef unless(defined($target) && $target ne '');

    # Format ping command
    my $cmd = "ping";
    # Add VRF parameter, if defined
    if(defined($vrf) && $vrf ne '') {
	$cmd .= " vrf ".$vrf;
    # Otherwise, add address family, if defined
    } elsif(defined($af) && $af ne '') {
	my $family = {4 => 'ipv4', 6 => 'ipv6'}->{$af};
	if(defined($family) && $family ne '') {
	    $cmd .= " ".$family;
	}
    }
    # Add ping target
    $cmd .= " ".$target;
    # Optional ping source address/interface
    if(defined($source) && $source ne '') {
	$cmd .= " source ".$source;
    }
    # Optional packet count parameter
    if(defined($packets) && $packets ne '') {
	$cmd .= " count ".$packets;
    }
    # Optional size parameter
    if(defined($size) && $size ne '') {
	$cmd .= " size ".$size;
    }
    # Optional ping timeout parameter
    if(defined($timeout) && $timeout ne '') {
	$cmd .= " timeout ".$timeout;
    }

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd."\n") if $debug;

    # Issue ping command and get the command's output
    my @output = $conn->cmd($cmd);

    # The last line of output contains the ping summary
    my $summary = pop @output;
    return undef unless defined($summary);

    chomp $summary;
    return undef unless $summary ne '';

    print_stdout($frontend, $summary."\n") if $debug;

    my %result;

    # Extract summary information
    @result{('received', 'sent', 'rttmin', 'rttavg', 'rttmax')} = ($summary =~ /^Success rate is \d+ percent \((\d+)\/(\d+)\)(?:, round\-trip min\/avg\/max = (\d+)\/(\d+)\/(\d+) ms)?$/i);

    return \%result;
}

#########################################################################
##                    F O R C E 1 0   D E V I C E                      ##
#########################################################################

sub __force10_ping($$;%)
{
    my $frontend = shift;
    my $conn = shift;

    # Get ping parameters
    my ($target, $source, $packets, $size, $timeout, $debug) =
	@{{@_}}{('target', 'source', 'packets', 'size', 'timeout', 'debug')};

    return undef unless(defined($target) && $target ne '');

    # Format ping command
    my $cmd = "ping ".$target;
    # Optional ping source address/interface
    if(defined($source) && $source ne '') {
	$cmd .= " source ".$source;
    }
    # Optional packet count parameter
    if(defined($packets) && $packets ne '') {
	$cmd .= " count ".$packets;
    }
    # Optional size parameter
    if(defined($size) && $size ne '') {
	$cmd .= " datagram-size ".$size;
    }
    # Optional ping timeout parameter
    if(defined($timeout) && $timeout ne '') {
	$cmd .= " timeout ".$timeout;
    }

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd."\n") if $debug;

    # Issue ping command and get the command's output
    my @output = $conn->cmd($cmd);

    # The last line of output contains the ping summary
    my $summary = pop @output;
    return undef unless defined($summary);

    chomp $summary;
    return undef unless $summary ne '';

    print_stdout($frontend, $summary."\n") if $debug;

    my %result;

    # Extract summary information
    @result{('received', 'sent', 'rttmin', 'rttavg', 'rttmax')} = ($summary =~ /^Success rate is \d+(?:\.\d+)? percent \((\d+)\/(\d+)\)(?:, round\-trip min\/avg\/max = (\d+)\/(\d+)\/(\d+) \(ms\))?$/i);

    return \%result;
}

#########################################################################
##          D E L L   P O W E R C O N N E C T   D E V I C E            ##
#########################################################################

sub __powerconnect_ping($$;%)
{
    my $frontend = shift;
    my $conn = shift;

    # Get ping parameters
    my ($target, $af, $packets, $size, $timeout, $debug) =
	@{{@_}}{('target', 'af', 'packets', 'size', 'timeout', 'debug')};

    return undef unless(defined($target) && $target ne '');

    # Format ping command
    my $cmd = "ping";
    # Add address family, if defined
    if(defined($af) && $af ne '') {
	my $family = {4 => 'ip', 6 => 'ipv6'}->{$af};
	if(defined($family) && $family ne '') {
	    $cmd .= " ".$family;
	}
    }
    # Add ping target
    $cmd .= " ".$target;
    # Optional packet count parameter
    if(defined($packets) && $packets ne '') {
	$cmd .= " repeat ".$packets;
    # Optional size parameter
    } elsif(defined($size) && $size ne '') {
	$cmd .= " size ".$size;
    # Optional ping timeout parameter
    } elsif(defined($timeout) && $timeout ne '') {
	$cmd .= " timeout ".$timeout;
    }

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd."\n") if $debug;

    # Issue ping command and get the command's output
    my @output = $conn->cmd($cmd);

    my %result = ();

    while((my $line = pop @output)) {
	if($line =~ /^round\-trip \(msec\) min\/avg\/max = (\d+)\/(\d+)\/(\d+)$/i) {
	    @result{('rttmin', 'rttavg', 'rttmax')} = ($1, $2, $3);
	} elsif($line =~ /^(\d+) packets transmitted, (\d+) packets received, \d+(\.\d+)?% packet loss$/i) {
	    @result{('sent','received')} = ($1, $2);
	    @output = ();
	} else {
	    next;
	}
	print_stdout($frontend, $line) if $debug;
    }

    return \%result;
}

#########################################################################
##                      J U N O S   D E V I C E                        ##
#########################################################################

sub __junos_ping($$;%)
{
    my $frontend = shift;
    my $conn = shift;

    # Get ping parameters
    my ($target, $af, $source, $packets, $size, $timeout, $vrf, $debug) =
	@{{@_}}{('target', 'af', 'source', 'packets', 'size', 'timeout', 'vrf', 'debug')};

    return undef unless(defined($target) && $target ne '');

    # We must explicitly set screen width to maximum.
    # Otherwise, commands we issue will be truncated
    $conn->cmd("set cli screen-width 1024");

    # Format ping command
    my $cmd = "ping ".$target." rapid";
    # Add VRF parameter, if defined
    if(defined($vrf) && $vrf ne '') {
	$cmd .= " routing-instance ".$vrf;
    }
    # Add address family, if defined
    if(defined($af) && $af ne '') {
	my $family = {4 => 'inet', 6 => 'inet6'}->{$af};
	if(defined($family) && $family ne '') {
	    $cmd .= " ".$family;
	}
    }
    # Optional ping source address/interface
    if(defined($source) && $source ne '') {
	$cmd .= " source ".$source;
    }
    # Optional packet count parameter
    if(defined($packets) && $packets ne '') {
	$cmd .= " count ".$packets;
    }
    # Optional size parameter
    if(defined($size) && $size ne '') {
	$cmd .= " size ".$size;
    }
    # Optional ping timeout parameter
    if(defined($timeout) && $timeout ne '') {
	$cmd .= " interval ".$timeout;
    }

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd."\n") if $debug;

    # Issue ping command and get the command's output
    my @output = $conn->cmd($cmd);

    my %result = ();

    while((my $line = pop @output)) {
	if($line =~ /^round-trip min\/avg\/max\/std\-?dev = (\d+(?:\.\d+)?)\/(\d+(?:\.\d+)?)\/(\d+(?:\.\d+)?)\/\d+(?:\.\d+)? ms$/i) {
	    @result{('rttmin', 'rttavg', 'rttmax')} = ($1, $2, $3);
	} elsif($line =~ /^(\d+) packets transmitted, (\d+) packets received, \d+(\.\d+)?% packet loss$/i) {
	    @result{('sent','received')} = ($1, $2);
	    @output = ();
	} else {
	    next;
	}
	print_stdout($frontend, $line) if $debug;
    }

    return \%result;
}

#########################################################################
##                     E N T R Y   P O I N T                           ##
#########################################################################

exit(main());
