#!/usr/bin/perl
# nagios: -epn
#########################################################################

#
# Copyright (c) 2016 Marko Dinic <marko@yu.net>. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#########################################################################

our (%PARAMS, %CONFIG, %PARAMS_DEFAULTS, %CONFIG_DEFAULTS);
our ($PROGRAM, $VERSION, $USAGE);

#########################################################################

($PROGRAM) = ($0 =~ /([^\/]+)$/);

$VERSION = "0.3";

#########################################################################
##      O P T I O N A L   S T A T I C   C O N F I G U R A T I O N      ##
#########################################################################

%PARAMS = ();
%CONFIG = ();

#########################################################################
##                          D E F A U L T S                            ##
#########################################################################

%PARAMS_DEFAULTS = (
    'size'		=> 100,
    'packets'		=> 5,
    'timeout'		=> 2
);

%CONFIG_DEFAULTS = (
    'maxattempts'	=> 3,
    'maxidle'		=> 60,
    'sockdir'		=> "/var/tmp"
);

#########################################################################
##                         I N T E R N A L S                           ##
#########################################################################


#########################################################################

use constant {
    RC_OK		=> 0,
    RC_WARNING		=> 1,
    RC_CRITICAL		=> 2,
    RC_UNKNOWN		=> 3
};

use constant {
    CLI_PROMPT		=> '.*?[>#]\s*$',
    PAGE_MARKER		=> '\-+\s*More\s*\-+'
};

#########################################################################

use strict;
use warnings;

#########################################################################

use Getopt::Std;

use POSIX qw(setsid);

use Digest::MD5 qw(md5_base64);
use IO::Select;
use IO::Socket::UNIX;
use Storable qw(nstore_fd fd_retrieve);

use Net::Telnet;

use Data::Dumper;

#########################################################################
##                   H E L P E R   F U N C T I O N S                   ##
#########################################################################

sub HELP_MESSAGE
{
    print STDERR <<EOF
$PROGRAM [options]

 -H <target_address>          Target (pinged) device's address

 -w <wrta>,<wpl>%             Warning threshold for average RTT and packet loss
 -c <crta>,<cpl>%             Critical threshold for average RTT and packet loss

 -D <remote_address>          Network device that will do the pinging
 -T <type>                    Type of pinging device (os/vendor):

                               ios
                               iosxr
                               force10
                               powerconnect
                               junos

                              Default: autodetect

 -U <username>                Pinging device's username
 -P <password>                Pinging device's password
 -E <secret>                  Elevated privilege level secret (ie. Cisco enable)

 -p <packets>                 Number of pings to send
 -s <size>                    Ping packets' size
 -t <timeout>                 Ping reply timeout

 -S <source>                  Ping packets' source address or interface
 -V <VRF>                     VRF to use instead of global routing table

 -4|6                         Use IPv4 or IPv6 explicitly

 -d                           Enable debugging

EOF
}

sub error(;$)
{
    my $message = shift;

    # If exit message was specified - print it
    if(defined($message) && $message ne '') {
	print STDERR "ERROR: ".$message."\n\n";
    }

    # Display help
    HELP_MESSAGE();

    return RC_UNKNOWN;
}

sub is_ipv4($)
{
    return (defined($_[0]) && $_[0] =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:\/\d{1,2})?$/) ? 1:0;
}

sub is_ipv6($)
{
    return (defined($_[0]) && $_[0] =~ /^[a-fA-F\d]{0,4}(?:\:(?!\:\:)[a-fA-F\d]{1,4}){0,6}(?:\:\:)?(?:[a-fA-F\d]{1,4}\:(?!\:\:)){0,6}[a-fA-F\d]{0,4}(?:\/\d{1,2})?$/) ? 1:0;
}

sub nslookup($)
{
    my $host = shift;
    my $addr;

    # getaddrinfo() and getnameinfo() are a mess - they are
    # missing from Socket module on some linux distributions
    # (or are otherwise unavailable), but not all. They can
    # also be found in Socket6 and Socket::GetAddrInfo modules,
    # but these are not installed by default. We will look for
    # them in all those places and if they are not found, we
    # will fall back to shell command 'host' (if installed).

    eval {
	eval {
	    eval {
		# Try Socket module
		eval {
		    require Socket;
		    import Socket qw(getaddrinfo getnameinfo NI_NUMERICHOST NIx_NOSERV);
		};
		# If not present in Socket,
		# look for Socket6 module
		if($@) {
		    require Socket6;
		    import Socket6;
		}
	    };
	    # If Socket6 module is missing,
	    # look for Socket::GetAddrInfo
	    if($@) {
		require Socket::GetAddrInfo;
		import Socket::GetAddrInfo qw(:newapi getaddrinfo getnameinfo NI_NUMERICHOST);
	    }
	    # If we reached this part,
	    # we found something
	    my ($err, $ai) = getaddrinfo($host, 0);
	    ($err, $addr) = getnameinfo($ai->{'addr'}, &NI_NUMERICHOST);
	};
	# If all else fails, try good ol' 'host' command
	if($@) {
	    ($addr) = (`host $host` =~ /has\s+(?:IPv6\s+)?address\s+([^\s\n\r]+)$/i);
	    die unless defined($addr) && $addr ne '';
	}
    };

    return ($@) ? $host:$addr;
}

#########################################################################
##             F R O N T E N D < - > D A E M O N   I P C               ##
#########################################################################

sub ipc_read($)
{
    my $socket = shift;

    return fd_retrieve($socket);
}

sub ipc_write($$)
{
    my ($socket, $data) = @_;

    return nstore_fd($data, $socket);
}

sub ipc_digest($$)
{
    my ($user, $pass) = @_;

    $user = '' unless defined($user);
    $pass = '' unless defined($pass);

    return md5_base64("\0".length($user)."\0".length($pass)."\0".$user.":".$pass);
}

#########################################################################
##                     D A E M O N   O U T P U T                       ##
#########################################################################

sub print_stdout($$)
{
    my ($socket, $message) = @_;

    ipc_write($socket, { 'stdout' => $message });
}

sub print_stderr($$)
{
    my ($socket, $message) = @_;

    ipc_write($socket, { 'stderr' => $message });
}

sub return_code($$)
{
    my ($socket, $code) = @_;

    ipc_write($socket, { 'code' => $code });
}

sub return_stats($$)
{
    my ($socket, $stats) = @_;

    ipc_write($socket, { 'stats' => $stats, 'code' => RC_OK });
}

#########################################################################
##               N E T W O R K   D E V I C E   C O R E                 ##
#########################################################################

sub detect_device_type($)
{
    my $cli = shift;

    # Request system version. Most platforms support this command
    $cli->put("show version\n");
    # Collect output up to command prompt or pagination marker
    my ($version, $prompt) = $cli->waitfor('/(?:'.PAGE_MARKER.'|'.CLI_PROMPT.')/i');
    # If output is paginated ...
    if(defined($prompt) && $prompt =~ /@{[PAGE_MARKER]}/i) {
	# ... end pagination
	$cli->put("q");
	$cli->waitfor('/'.CLI_PROMPT.'/');
    }

    # If version info is available, attempt platform detection
    if(defined($version) && $version ne '') {
	return 'ios' if $version =~ /Cisco IOS Software/i;
	return 'iosxr' if $version =~ /Cisco IOS XR Software/i;
	return 'force10' if $version =~ /Force10/i;
	return 'powerconnect' if $version =~ /PowerConnect/i;
	return 'junos' if $version =~ /JUNOS/i;
    }

    return '';
}

sub device_connect($$$$;$)
{
    my ($frontend, $device, $user, $pass, $debug) = @_;

    # Create new telnet session
    my $cli = Net::Telnet->new(Prompt => '/'.CLI_PROMPT.'/',
				Errmode => 'return',
				Timeout => 10);

    return undef unless defined($cli);

    # Telnet to remote network device
    $cli->open($device)
	or return undef;

    print_stdout($frontend, "Connected to remote network device ".$device."\n") if $debug;

    # Send username, if defined
    if(defined($user) && $user ne '') {
	print_stdout($frontend, "Sending username\n") if $debug;
	unless($cli->waitfor('/(?:[Uu]ser(?:name)?|[Ll]ogin):/')) {
	    print_stderr($frontend, "Username failed\n") if $debug;
	    $cli->close();
	    return undef;
	}
	$cli->put($user."\n");
    }

    # Send password, if defined
    if(defined($pass) && $pass ne '') {
	print_stdout($frontend, "Sending password\n") if $debug;
	unless($cli->waitfor('/[Pp]ass(?:word)?:/')) {
	    print_stderr($frontend, "Password failed\n") if $debug;
	    $cli->close();
	    return undef;
	}
	$cli->cmd($pass)
	    or return undef;
    }

    print_stdout($frontend, "Authenticated to remote network device ".$device."\n") if $debug;

    return $cli;
}

sub device_daemon($$;$$$$$)
{
    # Fork child process that will,
    # in turn, fork the actual daemon
    # completely dissociated from us
    my $pid = fork();
    return 0 unless defined($pid);
    if($pid > 0) {
	# Wait for child to fork the daemon and exit
	waitpid($pid, 0);
	return 1;
    }

    # Child process starts here

    chdir("/tmp");
    close(STDIN);
    close(STDOUT);
    close(STDERR);

    # Move process to the new session
    setsid();

    # Disable common signals that
    # could terminate the daemon
    $SIG{'ALRM'} =
    $SIG{'TERM'} =
    $SIG{'PIPE'} =
    $SIG{'CHLD'} =
    $SIG{'INT'} =
    $SIG{'HUP'} = 'IGNORE';

    # Disable host/service check timeout
    # we may have inherited from Nagios
    alarm(0);

    # Fork the daemon into background
    $pid = fork();
    exit() unless(defined($pid) && $pid == 0);

    # Daemon process starts here

    my ($sockpath, $device, $type, $user, $pass, $debug, $maxidle) = @_;

    # If UNIX socket is present ...
    if(-S $sockpath) {
	# ... try to connect
	my $sock = IO::Socket::UNIX->new(Type => &SOCK_STREAM,
					 Peer => $sockpath);
	# If connected successfully,
	# another daemon is already
	# listening on this socket
	if(defined($sock)) {
	    # Close it ...
	    $sock->close();
	    # ... and quit
	    exit();
	}
	# Otherwise, remove stale socket
	unlink($sockpath);
    }

    # Create new UNIX socket to talk to our frontend
    my $listener = IO::Socket::UNIX->new(Type => &SOCK_STREAM,
					 Local => $sockpath,
					 Listen => &SOMAXCONN,
					 Blocking => 0);

    exit() unless defined($listener);

    # Monitor listener socket for incoming connections
    my $select = IO::Select->new();
    $select->add($listener);

    # Initial daemon process's title
    my $baseproctitle = "no cli session";
    my $proctitle = $baseproctitle;
    $0 = $proctitle;

    my ($func_ping, $func_parse);
    my ($frontend, $cli, $params);
    my $detected;

    my @requests = ();

    my $idle_timeout = time() + $maxidle;
    my $cmd_timeout;

    # Main loop will run as long as
    # daemon is not idle for more
    # than specified maxidle time
    while((my $idle_remaining = $idle_timeout - time()) > 0) {

	if($idle_remaining < $maxidle) {
	    $0 = $proctitle.", idle shutdown in ".$idle_remaining." sec";
	}

	# Wait until listening socket is ready
	my @ready = $select->can_read(0.1);
	# Pick up and handle ready sockets
	foreach my $socket (@ready) {
	    # If ready socket is the listening socket ...
	    if($socket == $listener) {
		# ... we have incoming connection
		my $incoming = $socket->accept();
		# Make new connection non-blocking
		$incoming->blocking(0);
		# Start monitoring it for input
		$select->add($incoming);
	    # If ready socket is the active frontend ...
	    } elsif(defined($frontend) && 
		    $socket == $frontend) {
		# ... we are not expecting more input
		# from the frontend, so we will assume
		# this was the socket closing event.
		# Force the ping in progress to timeout
		# immediately
		$cmd_timeout = 0;
	    # If ready socket is a newly accepted
	    # connection from a frontend ...
	    } else {
		# ... get ping parameters
		my $params = ipc_read($socket);
		# If socket was ready, but we got no params,
		# frontend disconnected prematurely or sent
		# junk that we couldn't handle
		unless(defined($params)) {
		    $select->remove($socket);
		    $socket->close();
		    next;
		}
		# Keep socket to the frontend
		# with other ping parameters
		$params->{'frontend'} = $socket;
		# Queue received parameters
		push @requests, $params;
	    }
	}

	# If we are idle ...
	unless(defined($frontend)) {
	    # ... take the next request
	    $params = shift @requests;
	    next unless defined($params);
	    # Requesting frontend's UNIX socket
	    my $socket = $params->{'frontend'};
	    # If params contain debug flag (as they should) ...
	    if(defined($params->{'debug'})) {
		# ... replace daemon's current debug setting
		$debug = $params->{'debug'};
	    }
	    # Parameters must be 'signed' with MD5 digest
	    # formatted from device's login credentials.
	    # This ensures that the frontend is invoked
	    # with proper device credentials while daemon
	    # is running. Otherwise, device credentials
	    # would be required only the first time, to
	    # allow daemon to initially authenticate to
	    # the remote device, but since the session
	    # will be in the established state from that
	    # point on, subsequent frontend runs would
	    # land in the middle of already established
	    # CLI session without auth.
	    unless($params->{'digest'} eq ipc_digest($user, $pass)) {
		print_stderr($socket, "Invalid credentials for device ".$device."\n") if $debug;
		return_code($socket, RC_UNKNOWN);
		$select->remove($socket);
		$socket->close();
		next;
	    }
	    # If not connected to the device yet ...
	    unless(defined($cli)) {
		# ... attempt to connect now
		$cli = device_connect($socket, $device, $user, $pass, $debug);
		unless(defined($cli)) {
		    print_stderr($socket, "Failed to connect to network device ".$device."\n") if $debug;
		    return_code($socket, RC_UNKNOWN);
		    $select->remove($socket);
		    $socket->close();
		    last;
		}
		# If device type wasn't specified ...
		unless(defined($type) && $type ne '') {
		    # ... attempt to detect it
		    $detected = detect_device_type($cli);
		    # If device type was detected ...
		    if(defined($detected) && $detected ne '') {
			print_stdout($socket, "Detected network device type ".$detected."\n") if $debug;
			# ... force device-specific ping function lookup
			undef $func_ping;
			undef $func_parse;
		    }
		}
		# Set daemon proctitle to reflect connected state
		$proctitle = "cli session established with ".$device;
		$0 = $proctitle;
	    }
	    # If device-specific functions aren't known ...
	    unless(defined($func_ping) && ref($func_ping) eq 'CODE' &&
		   defined($func_parse) && ref($func_parse) eq 'CODE') {
		# Explicitly defined device type overrides autodetected one
		my $device_type = (defined($type) && $type ne '') ? $type:$detected;
		# Determine mandatory device-specific functions
		$func_ping = __PACKAGE__->can('__'.$device_type.'_ping');
		$func_parse = __PACKAGE__->can('__'.$device_type.'_parse');
		# If device type is supported, platform-specific
		# ping functions exist and we have coderef to them
		unless(defined($func_ping) && ref($func_ping) eq 'CODE' &&
		       defined($func_parse) && ref($func_parse) eq 'CODE') {
		    # Otherwise, this device type is not supported
		    print_stderr($socket, "Unsupported device type ".$type."\n") if $debug;
		    return_code($socket, RC_UNKNOWN);
		    $select->remove($socket);
		    $socket->close();
		    last;
		}
	    }

	    # Set telnet cmd (send command, wait for prompt) timeout
	    $cmd_timeout = $params->{'timeout'} * ($params->{'packets'} + 1);
	    $cli->timeout($cmd_timeout);
	    $cmd_timeout += time();

	    # Start pinging the target
	    if($func_ping->($cli, %{$params})) {
		# Keep active frontend's socket
		# until request has been completed
		$frontend = $socket;
		# Set proctitle to reflect
		# daemon's current operation
		$0 = $proctitle.", pinging ".$params->{'target'};
		$0 .= " inside VRF ".$params->{'vrf'} if(defined($params->{'vrf'}) &&
							 $params->{'vrf'} ne '');
	    # If ping command failed ...
	    } else {
		# ... report error
		print_stderr($socket, "Command failed\n") if $debug;
		return_code($socket, RC_UNKNOWN);
		# Also ...
		if(defined($cli)) {
		    # ... close the connection in case
		    # command failed because something
		    # messed up the CLI session
		    $cli->close();
		    # Force daemon to reconnect
		    undef $cli;
		    # Change proctitle to reflect our disconnected state
		    $proctitle = $baseproctitle;
		}
		# ... stop monitoring socket for events
		$select->remove($socket);
		# ... and disconnect the frontend
		$socket->close();
	    }

	    # Reset idle timeout
	    $idle_timeout = time() + $maxidle;

	}

	# Ping in progress ?
	if(defined($frontend)) {
	    # Check if ping command finished
	    my ($output) = $cli->waitfor(Match => '/'.CLI_PROMPT.'/', Timeout => 1);
	    # If we got output, command has finished
	    if(defined($output) && $output ne '') {
		# Split command output into separate lines
		my @results = split(/[\n\r]/, $output);
		# Parse command output
		my $stats = $func_parse->($cli, \@results, %{$params});
		# If we received ping statistics ...
		if(defined($stats)) {
		    # ... send them to the frontend
		    return_stats($frontend, $stats);
		# Otherwise ...
		} else{
		    # ... return generic error code
		    return_code($frontend, RC_UNKNOWN);
		}
	    # If we got no output, ping is still in progress
	    } else {
		# Reset idle timeout
		$idle_timeout = time() + $maxidle;
		# Keep waiting until command finishes or times out
		next if(time() < $cmd_timeout);
		# On timeout, return error message and code
		print_stderr($frontend, "Command failed\n") if $debug;
		return_code($frontend, RC_UNKNOWN);
		# If command was aborted or timed out ...
		if(defined($cli)) {
		    # ... close the connection in case
		    # something messed up CLI session
		    $cli->close();
		    # Force daemon to reconnect
		    undef $cli;
		    # Change proctitle to reflect our disconnected state
		    $proctitle = $baseproctitle;
		}
	    }
	    # Stop monitoring socket for events
	    $select->remove($frontend);
	    # Disconnect the frontend
	    $frontend->close();
	    # Make us idle again
	    undef $frontend;
	    undef $params;
	}

    }

    # If connected to the remote device ...
    if(defined($cli)) {
	# ... end CLI session
	$cli->put("exit");
	# ... close telnet session
	$cli->close();
    }

    # If listening on UNIX socket ...
    if(defined($listener)) {
	# ... stop monitoring socket
	$select->remove($listener);
	# ... close it
	$listener->close();
    }

    # If socket file exists ...
    if(-S $sockpath) {
	# ... remove it
	unlink($sockpath);
    }

    # Done
    exit(0);
}

#########################################################################
##                              M A I N                                ##
#########################################################################

sub main()
{
    my %cf = (%CONFIG_DEFAULTS, %CONFIG);

    return error "Script config is invalid/incomplete" unless(defined($cf{'maxattempts'}) &&
								      $cf{'maxattempts'} =~ /^\d+$/ &&
								      $cf{'maxattempts'} >= 0 &&
							      defined($cf{'maxidle'}) &&
								      $cf{'maxidle'} =~ /^\d+$/ &&
								      $cf{'maxidle'} >= 0 &&
							      defined($cf{'sockdir'}) &&
								      -d $cf{'sockdir'});

    my %opts = ();

    # Parse command line arguments
    $Getopt::Std::STANDARD_HELP_VERSION = 1;
    getopts("D:T:U:P:E:H:S:V:p:s:t:w:c:d46", \%opts);

    my %params = (%PARAMS_DEFAULTS, %PARAMS);
    my ($device, $type);
    my ($user, $pass);
    my ($warn_rta, $warn_pl);
    my ($crit_rta, $crit_pl);
    my $debug;

    # Statically configured ping parameters
    # can be overrriden by runtime options
    while(my ($opt, $val) = each %opts) {
	# Process available options
	if($opt eq 'D') {
	    return error "Missing/invalid pinging device hostname/address" unless $val ne '';
	    # Set pinging device address
	    $device = $val;
	} elsif($opt eq 'T') {
	    return error "Missing/invalid pinging device type (os/vendor)" unless defined($val);
	    # Set pinging device type
	    $type = $val if $val ne '';
	} elsif($opt eq 'U') {
	    return error "Missing pinging device username" unless defined($val);
	    # Set pinging device's telnet username
	    $user = $val if $val ne '';
	} elsif($opt eq 'P') {
	    return error "Missing pinging device password" unless defined($val);
	    # Set pinging device's telnet password
	    $pass = $val if $val ne '';
	} elsif($opt eq 'E') {
	    return error "Missing pinging device enable password" unless defined($val);
	    # Set pinging device's enable password
	    $params{'enable'} = $val if $val ne '';
	} elsif($opt eq 'H') {
	    return error "Missing ping target hostname/address" unless $val ne '';
	    # Set ping target address
	    $params{'target'} = (is_ipv4($val) || is_ipv6($val)) ? $val:nslookup($val);
	} elsif($opt eq 'S') {
	    return error "Missing ping source address/interface" unless defined($val);
	    # Set ping source address
	    $params{'source'} = $val if $val ne '';
	} elsif($opt eq 'V') {
	    return error "Missing/invalid VRF" unless defined($val);
	    # Set pinging source VRF
	    $params{'vrf'} = $val if $val ne '';
	} elsif($opt eq 'p') {
	    return error "Missing packet count" unless defined($val);
	     # Set the number of packets to ping with
	    $params{'packets'} = $val if($val =~ /^\d+$/ && $val > 0);
	} elsif($opt eq 's') {
	    return error "Missing packet size" unless defined($val);
	    # Set the ping packet size
	    $params{'size'} = $val if($val =~ /^\d+$/ && $val > 35);
	} elsif($opt eq 't') {
	    return error "Missing ping timeout" unless defined($val);
	    # Set the ping timeout
	    $params{'timeout'} = $val if($val =~ /^\d+$/ && $val > 0);
	} elsif($opt eq 'w') {
	    return error "Missing warning thresholds" unless $val ne '';
	    # Extract average RTT and packed loss thresholds
	    ($warn_rta, $warn_pl) = ($val =~ /^(\d+),(\d+)\%$/);
	    unless(defined($warn_rta) && $warn_rta ne '' &&
		   defined($warn_pl) && $warn_pl ne '') {
		return error "Invalid warning thresholds ".$val;
	    }
	} elsif($opt eq 'c') {
	    return error "Missing critical thresholds" unless $val ne '';
	    # Extract average RTT and packed loss thresholds
	    ($crit_rta, $crit_pl) = ($val =~ /^(\d+),(\d+)\%$/);
	    unless(defined($crit_rta) && $crit_rta ne '' &&
		   defined($crit_pl) && $crit_pl ne '') {
		return error "Invalid critical thresholds ".$val;
	    }
	} elsif($opt eq '4') {
	    $params{'af'} = 4;
	} elsif($opt eq '6') {
	    $params{'af'} = 6;
	} elsif($opt eq 'd') {
	    # Enable debugging
	    $params{'debug'} = $debug = 1;
	} else {
	    return error;
	}
    }

    # Check for mandatory parameters: device, target and thresholds
    # and do internal configuration sanity chech
    return error unless(defined($params{'target'}) &&
				$params{'target'} ne '' &&
			defined($device) &&
				$device ne '' &&
			defined($warn_rta) &&
				$warn_rta =~ /^\d+$/ &&
				$warn_rta >= 0 &&
			defined($warn_pl) &&
				$warn_pl  =~ /^\d+$/ &&
				$warn_pl >= 0 &&
			defined($crit_rta) &&
				$crit_rta =~ /^\d+$/ &&
				$crit_rta >= 0 &&
			defined($crit_pl) &&
				$crit_pl =~ /^\d+$/ &&
				$crit_pl >= 0);

    # Resolve network device name into an IPv4/IPv6 address
    my $devaddr = (is_ipv4($device) || is_ipv6($device)) ? $device:nslookup($device);
    return RC_UNKNOWN unless(defined($devaddr) && $devaddr ne '');

    # UNIX socket name will be the IP address of the device
    my $sockpath = $cf{'sockdir'}."/".$devaddr.".sock";

    my ($daemon, $pid);

    # Try to connect to the device daemon
    for(1..$cf{'maxattempts'}) {
	# Connect to device daemon via UNIX socket
	$daemon = IO::Socket::UNIX->new(Type => &SOCK_STREAM,
					Peer => $sockpath,
					Blocking => 0);
	# Connection was successful, we are done
	if(defined($daemon)) {
	    print "Attached to device ".$device." daemon\n" if $debug;
	    last;
	}
	# If connection failed, assume
	# that daemon isn't running
	unless($pid) {
	    # Start the daemon
	    $pid = device_daemon($sockpath,
				 $device,
				 $type,
				 $user,
				 $pass,
				 $debug,
				 $cf{'maxidle'});
	    # Daemon launch failed ?
	    return RC_UNKNOWN unless defined($pid);
	    print "Started device ".$device." daemon\n" if $debug;
	}
	# Wait before retrying
	sleep(1);
    }

    return RC_UNKNOWN unless defined($daemon);

    # Monitor connection to the daemon for incoming data
    my $select = IO::Select->new();
    $select->add($daemon);

    my $run = 1;

    # On SIGTERM or SIGINT, end the main loop
    $SIG{'TERM'} = $SIG{'INT'} = sub { $run = 0; };

    # Add auth digest to parameters
    $params{'digest'} = ipc_digest($user, $pass);

    # Send serialized ping parameters to the daemon
    ipc_write($daemon, \%params);

    print "Sent ping parameters to the daemon\n" if $debug;

    my ($stats, $code);

    # Read daemon output
    while($run) {
	# Wait until daemon sends some data,
	# or connection closes
	next unless $select->can_read(0.1);
	# Get input from daemon
	my $message = ipc_read($daemon);
	# If socket was ready, but we got no data,
	# we got disconnected from the socket
	last unless $message;
	# If daemon sent data to be written to stdout ...
	if(defined($message->{'stdout'})) {
	    # ... write it to stdout
	    print STDOUT $message->{'stdout'};
	}
	# If daemon sent data to be written to stderr ...
	if(defined($message->{'stderr'})) {
	    # ... write it to stderr
	    print STDERR $message->{'stderr'};
	}
	# If daemon sent ping stats ...
	if(defined($message->{'stats'})) {
	    # ... keep them
	    $stats = $message->{'stats'};
	}
	# If daemon sent exit code ...
	if(defined($message->{'code'})) {
	    # ... keep the code ...
	    $code = $message->{'code'};
	    # ... and end the loop
	    last;
	}
    }

    # Disconnect from the daemon
    $daemon->close();

    # If daemon returned a non-0 exit code,
    # we will exit with that code
    return $code if $code;

    # If we got no stats, we cannot do anything
    return RC_UNKNOWN unless defined($stats);

    if($debug) {
	$Data::Dumper::Terse = 1;
	print "Ping stats: ".Dumper($stats)."\n";
    }

    # We must have at least the number of sent/received packets
    return RC_UNKNOWN unless(defined($stats->{'received'}) &&
				     $stats->{'received'} =~ /^\d+(?:\.\d+)?$/ &&
			     defined($stats->{'sent'}) &&
				     $stats->{'sent'} =~ /^\d+(?:\.\d+)?$/);

    # Calculate packet loss percentage
    my $packet_loss = sprintf("%.2f", (100 * (1 - ($stats->{'received'} / $stats->{'sent'}))));

    # Format average RTT
    my $rtt_average = (defined($stats->{'rttavg'}) &&
		       $stats->{'rttavg'} =~ /^\d+(?:\.\d+)?$/) ?
					sprintf("%.2f", $stats->{'rttavg'}):undef;

    my $rc = RC_OK;

    # Check if packet loss exceeds user-specified critical level
    if($packet_loss >= $crit_pl) {
	$rc = RC_CRITICAL;
    # Check if RTT average exceeds user-specified critical level
    } elsif(defined($rtt_average) && $rtt_average >= $crit_rta) {
	$rc = RC_CRITICAL;
    # Check if packet loss exceeds user-specified warning level
    } elsif($packet_loss >= $warn_pl) {
	$rc = RC_WARNING;
    # Check if RTT average exceeds user-specified warning level
    } elsif(defined($rtt_average) && $rtt_average >= $warn_rta) {
	$rc = RC_WARNING;
    }

    my %rc_str = (
	&RC_OK		=> "OK",
	&RC_WARNING	=> "WARNING",
	&RC_CRITICAL	=> "CRITICAL"
    );

    print "PING ".$rc_str{$rc}." - Packet loss = ".$packet_loss."%";
    print ", RTA = ".$rtt_average." ms" if defined($rtt_average);
    print "\n";

    return $rc;
}

#########################################################################
##                  C I S C O   I O S   D E V I C E                    ##
#########################################################################

sub __ios_ping($;%)
{
    my $cli = shift;

    # Get ping parameters
    my ($frontend, $enable, $target, $af, $source, $packets, $size, $timeout, $vrf, $debug) =
	@{{@_}}{('frontend', 'enable', 'target', 'af', 'source', 'packets', 'size', 'timeout', 'vrf', 'debug')};

    return 0 unless(defined($target) && $target ne '');

    # Change to enable mode, if defined
    if(defined($enable) && $enable ne '') {
	print_stdout($frontend, "Sending enable password\n") if $debug;
	$cli->cmd(String => "enable", Prompt => '/[Pp]assword:/', Timeout => 1);
	unless($cli->cmd(String => $enable, Prompt => '/#$/', Timeout => 1)) {
	    $cli->cmd("\n\n");
	    print_stderr($frontend, "Enable failed\n") if $debug;
	    return 0;
	}
    }

    # Format ping command
    my $cmd = "ping";
    # Add VRF parameter if defined
    if(defined($vrf) && $vrf ne '') {
	$cmd .= " vrf ".$vrf;
    }
    # Add address family if defined
    if(defined($af) && $af ne '') {
	my $family = {4 => 'ip', 6 => 'ipv6'}->{$af};
	if(defined($family) && $family ne '') {
	    $cmd .= " ".$family;
	}
    }
    # Add ping target
    $cmd .= " ".$target;
    # Ping with packet parameters requires enable mode
    if(defined($enable) && $enable ne '') {
	# Optional ping source address/interface
	if(defined($source) && $source ne '') {
	    $cmd .= " source ".$source;
	}
	# Optional packet count parameter
	if(defined($packets) && $packets ne '') {
	    $cmd .= " repeat ".$packets;
	}
	# Optional size parameter
	if(defined($size) && $size ne '') {
	    $cmd .= " size ".$size;
	}
	# Optional ping timeout parameter
	if(defined($timeout) && $timeout ne '') {
	    $cmd .= " timeout ".$timeout;
	}
    }
    $cmd .= "\n";

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd) if $debug;

    # Issue ping command and get the command's output
    $cli->put($cmd);

    return 1;
}

sub __ios_parse($$;%)
{
    my $cli = shift;
    my $output = shift;

    # Get ping parameters
    my ($frontend, $debug) = @{{@_}}{('frontend', 'debug')};

    my %result;

    # Exit privileged mode, if there was one
    $cli->cmd(String => "disable", Timeout => 1);

    # The last line of output contains the ping summary
    my $summary = pop @{$output};
    return undef unless defined($summary);

    chomp $summary;
    return undef unless $summary ne '';

    print_stdout($frontend, $summary."\n") if $debug;

    # Extract summary information
    @result{('received', 'sent', 'rttmin', 'rttavg', 'rttmax')} = ($summary =~ /^Success rate is \d+ percent \((\d+)\/(\d+)\)(?:, round\-trip min\/avg\/max = (\d+)\/(\d+)\/(\d+) ms)?$/i);

    return \%result;
}

#########################################################################
##              C I S C O   I O S   X R   D E V I C E                  ##
#########################################################################

sub __iosxr_ping($;%)
{
    my $cli = shift;

    # Get ping parameters
    my ($frontend, $target, $af, $source, $packets, $size, $timeout, $vrf, $debug) =
	@{{@_}}{('frontend', 'target', 'af', 'source', 'packets', 'size', 'timeout', 'vrf', 'debug')};

    return 0 unless(defined($target) && $target ne '');

    # Format ping command
    my $cmd = "ping";
    # Add VRF parameter, if defined
    if(defined($vrf) && $vrf ne '') {
	$cmd .= " vrf ".$vrf;
    # Otherwise, add address family, if defined
    } elsif(defined($af) && $af ne '') {
	my $family = {4 => 'ipv4', 6 => 'ipv6'}->{$af};
	if(defined($family) && $family ne '') {
	    $cmd .= " ".$family;
	}
    }
    # Add ping target
    $cmd .= " ".$target;
    # Optional ping source address/interface
    if(defined($source) && $source ne '') {
	$cmd .= " source ".$source;
    }
    # Optional packet count parameter
    if(defined($packets) && $packets ne '') {
	$cmd .= " count ".$packets;
    }
    # Optional size parameter
    if(defined($size) && $size ne '') {
	$cmd .= " size ".$size;
    }
    # Optional ping timeout parameter
    if(defined($timeout) && $timeout ne '') {
	$cmd .= " timeout ".$timeout;
    }
    $cmd .= "\n";

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd) if $debug;

    # Issue ping command
    $cli->put($cmd);

    return 1;
}

sub __iosxr_parse($$;%)
{
    my $cli = shift;
    my $output = shift;

    # Get ping parameters
    my ($frontend, $debug) = @{{@_}}{('frontend', 'debug')};
    my %result;

    # The last line of output contains the ping summary
    my $summary = pop @{$output};
    return undef unless defined($summary);

    chomp $summary;
    return undef unless $summary ne '';

    print_stdout($frontend, $summary."\n") if $debug;

    # Extract summary information
    @result{('received', 'sent', 'rttmin', 'rttavg', 'rttmax')} = ($summary =~ /^Success rate is \d+ percent \((\d+)\/(\d+)\)(?:, round\-trip min\/avg\/max = (\d+)\/(\d+)\/(\d+) ms)?$/i);

    return \%result;
}

#########################################################################
##                    F O R C E 1 0   D E V I C E                      ##
#########################################################################

sub __force10_ping($;%)
{
    my $cli = shift;

    # Get ping parameters
    my ($frontend, $target, $source, $packets, $size, $timeout, $debug) =
	@{{@_}}{('frontend', 'target', 'source', 'packets', 'size', 'timeout', 'debug')};

    return 0 unless(defined($target) && $target ne '');

    # Format ping command
    my $cmd = "ping ".$target;
    # Optional ping source address/interface
    if(defined($source) && $source ne '') {
	$cmd .= " source ".$source;
    }
    # Optional packet count parameter
    if(defined($packets) && $packets ne '') {
	$cmd .= " count ".$packets;
    }
    # Optional size parameter
    if(defined($size) && $size ne '') {
	$cmd .= " datagram-size ".$size;
    }
    # Optional ping timeout parameter
    if(defined($timeout) && $timeout ne '') {
	$cmd .= " timeout ".$timeout;
    }
    $cmd .= "\n";

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd) if $debug;

    # Issue ping command
    $cli->put($cmd);

    return 1;
}

sub __force10_parse($$;%)
{
    my $cli = shift;
    my $output = shift;

    # Get ping parameters
    my ($frontend, $debug) = @{{@_}}{('frontend', 'debug')};
    my %result;

    # The last line of output contains the ping summary
    my $summary = pop @{$output};
    return undef unless defined($summary);

    chomp $summary;
    return undef unless $summary ne '';

    print_stdout($frontend, $summary."\n") if $debug;

    # Extract summary information
    @result{('received', 'sent', 'rttmin', 'rttavg', 'rttmax')} = ($summary =~ /^Success rate is \d+(?:\.\d+)? percent \((\d+)\/(\d+)\)(?:, round\-trip min\/avg\/max = (\d+)\/(\d+)\/(\d+) \(ms\))?$/i);

    return \%result;
}

#########################################################################
##          D E L L   P O W E R C O N N E C T   D E V I C E            ##
#########################################################################

sub __powerconnect_ping($;%)
{
    my $cli = shift;

    # Get ping parameters
    my ($frontend, $target, $af, $packets, $size, $timeout, $debug) =
	@{{@_}}{('frontend', 'target', 'af', 'packets', 'size', 'timeout', 'debug')};

    return 0 unless(defined($target) && $target ne '');

    # Format ping command
    my $cmd = "ping";
    # Add address family, if defined
    if(defined($af) && $af ne '') {
	my $family = {4 => 'ip', 6 => 'ipv6'}->{$af};
	if(defined($family) && $family ne '') {
	    $cmd .= " ".$family;
	}
    }
    # Add ping target
    $cmd .= " ".$target;
    # Optional packet count parameter
    if(defined($packets) && $packets ne '') {
	$cmd .= " repeat ".$packets;
    # Optional size parameter
    } elsif(defined($size) && $size ne '') {
	$cmd .= " size ".$size;
    # Optional ping timeout parameter
    } elsif(defined($timeout) && $timeout ne '') {
	$cmd .= " timeout ".$timeout;
    }
    $cmd .= "\n";

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd) if $debug;

    # Issue ping command
    $cli->put($cmd);

    return 1;
}

sub __powerconnect_parse($$;%)
{
    my $cli = shift;
    my $output = shift;

    # Get ping parameters
    my ($frontend, $debug) = @{{@_}}{('frontend', 'debug')};
    my %result;

    while(defined(my $line = pop @{$output})) {
	if($line =~ /^round\-trip \(msec\) min\/avg\/max = (\d+)\/(\d+)\/(\d+)$/i) {
	    @result{('rttmin', 'rttavg', 'rttmax')} = ($1, $2, $3);
	} elsif($line =~ /^(\d+) packets transmitted, (\d+) packets received, \d+(\.\d+)?% packet loss$/i) {
	    @result{('sent','received')} = ($1, $2);
	    $output = [];
	} else {
	    next;
	}
	print_stdout($frontend, $line) if $debug;
    }

    return \%result;
}

#########################################################################
##                      J U N O S   D E V I C E                        ##
#########################################################################

sub __junos_ping($;%)
{
    my $cli = shift;

    # Get ping parameters
    my ($frontend, $target, $af, $source, $packets, $size, $timeout, $vrf, $debug) =
	@{{@_}}{('frontend', 'target', 'af', 'source', 'packets', 'size', 'timeout', 'vrf', 'debug')};

    return 0 unless(defined($target) && $target ne '');

    # We must explicitly set screen width to maximum.
    # Otherwise, commands we issue will be truncated
    $cli->cmd("set cli screen-width 1024");

    # Format ping command
    my $cmd = "ping ".$target." rapid";
    # Add VRF parameter, if defined
    if(defined($vrf) && $vrf ne '') {
	$cmd .= " routing-instance ".$vrf;
    }
    # Add address family, if defined
    if(defined($af) && $af ne '') {
	my $family = {4 => 'inet', 6 => 'inet6'}->{$af};
	if(defined($family) && $family ne '') {
	    $cmd .= " ".$family;
	}
    }
    # Optional ping source address/interface
    if(defined($source) && $source ne '') {
	$cmd .= " source ".$source;
    }
    # Optional packet count parameter
    if(defined($packets) && $packets ne '') {
	$cmd .= " count ".$packets;
    }
    # Optional size parameter
    if(defined($size) && $size ne '') {
	$cmd .= " size ".$size;
    }
    # Optional ping timeout parameter
    if(defined($timeout) && $timeout ne '') {
	$cmd .= " interval ".$timeout;
    }
    $cmd .= "\n";

    # Display debugging if requested
    print_stdout($frontend, "Executing ".$cmd) if $debug;

    # Issue ping command 
    $cli->put($cmd);

    return 1;
}

sub __junos_parse($$;%)
{
    my $cli = shift;
    my $output = shift;

    # Get ping parameters
    my ($frontend, $debug) = @{{@_}}{('frontend', 'debug')};

    my %result;

    while(defined(my $line = pop @{$output})) {
	if($line =~ /^round-trip min\/avg\/max\/std\-?dev = (\d+(?:\.\d+)?)\/(\d+(?:\.\d+)?)\/(\d+(?:\.\d+)?)\/\d+(?:\.\d+)? ms$/i) {
	    @result{('rttmin', 'rttavg', 'rttmax')} = ($1, $2, $3);
	} elsif($line =~ /^(\d+) packets transmitted, (\d+) packets received, \d+(\.\d+)?% packet loss$/i) {
	    @result{('sent','received')} = ($1, $2);
	    $output = [];
	} else {
	    next;
	}
	print_stdout($frontend, $line."\n") if $debug;
    }

    return \%result;
}

#########################################################################
##                     E N T R Y   P O I N T                           ##
#########################################################################

exit(main());
